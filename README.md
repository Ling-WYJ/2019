# 2019
经典的哈希表——TwoSum问题
Description
给一个整数数组，找到两个数使得他们的和等于一个给定的数target。你需要实现的函数twoSum需要返回这两个数的下标, 并且第一个下标小于第二个下标。注意这里下标的范围是 1 到 n，不是以 0 开头。数组是给定的，允许对数组建索引，每次的问题输入是target。

要求：需使用C++类与对象的方法实现哈希表的定义，哈希函数及冲突处理方法可自定义。

Input
控制台输入三行，第一行表示数组的大小，第二行顺序输入整数，第三行输入目标值。


Output
输出查询到的下标，注意：

（1）输出的两个下标是从1开始计数，且前一个数的下标小于后一个数；

（2）按照第一个数的下标递增依次换行输出所有的结果。

（3）最后一行保留一个换行空格；

（4）如果不存在，则返回None。


Sample Input 1                              
4                                      
2 7 11 15
9
Sample Output 1 
[1,2]

Sample Input 2                         
10                                      
2 5 11 8 1 7 4 16 13 3                  
15                                      
Sample Output 2
[1,9]
[3,7]
[4,6]
Sample Input 3                           
3                                       
1 2 3
2
Sample Output 3
None


滑雪问题
Description

Michael喜欢滑雪这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。

下面是一个例子:一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。


Input
输入的第一行表示区域的行数R和列数C(1 <= R,C <= 100)。下面是R行，每行有C个整数，代表高度h，0<=h<=10000。


Output
输出最长区域的长度。
Sample Input 
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
Sample Output 
25



堆排序的应用——TopK
Description

有一堆二维坐标点<x1,y1>, <x2, y2>…..<xn, yn>。假定坐标点是一个一个来的，请利用堆，能时刻报告数据中的最小的k项。比如k=1,  有4个坐标数据 <2,2>, <1,1>, <3,3>, <0,0> 依次到来。那么当来第一个<2,2>时， top-1的值是<2,2>, 再来一个数据<1,1>,这时top-1的值变为了 <1,1>, 再来一个<3,3>数据，top-1还是<1,1>, 第四个数据<0,0>到了后，top-1 就变为了 <0,0>。


Input
输入部分包括几个部分：

第一行，两个整型数，表示输入的坐标个数N以及K值。

第二行至第N+1行，每行包括两个整型数，分别表示坐标的X和Y值；


Output
输出若干行，每行表示坐标的X和Y值，输出格式为坐标格式(X,Y)，最后不要留换行空格。

注意：输入的前K-1个数时不需要打印，当输入第K个值时，每次输入一个坐标，返回topK个坐标，

注意每次输出的K个坐标时由小到大排序的。

Sample Input 1
4 1
2 2
1 1
3 3
0 0
Sample Output 1
(2,2)
(1,1)
(1,1)
(0,0)

Sample Input 2
5 3
2 0
3 2
2 2
1 8
3 6
Sample Output 2
(2,0)
(2,2)
(3,2)
(1,8)
(2,0)
(2,2)
(1,8)
(2,0)
(2,2)


BinaryTree
Description

1、给出层序遍历序列abc##de(#代表空指针), 构建二叉树。

2、实现一个函数，检查二叉树是否平衡。平衡树的定义：任意一个节点，其两棵子树的高度差不超过1。

3、找出二叉树中某两个节点的最近公共祖先。最近公共祖先的定义：对于有跟树T的两个节点p,q，最近公共祖先表示为一个结点x，满足x是p、q的祖先且x的深度尽可能大（一个节点也可以是它自己的祖先）。

说明：所有节点的值都是唯一的，p,q为不同节点且均存在于给定的二叉树中。


Input
1、层序遍历序列

2、二叉树中两个节点p和q的值


Output
1、输出二叉树是否是平衡二叉树
2、输出两个节点p和q的最近公共祖先的值

Sample Input 1 
abc##de
d e
Sample Output 1
true
c
